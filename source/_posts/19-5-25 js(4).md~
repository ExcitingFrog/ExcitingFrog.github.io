---
title: 19-5-25 js(4)
date: 2019-5-25 18:28:59
tags: 
- 2019
- js
---

### Vue 基础
参考资料 [Vue官方文档](https://cn.vuejs.org/v2/guide)
<!-- more-->
#### 基础
最简单的方法是直接引用就行
```html
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
或者：
<!-- 生产环境版本，优化了尺寸和速度 -->
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
<div id="app">
  {{ message }}
</div>
```
```js
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```
运行之后，可以在控制台里面对app.message进行修改

还可以绑定信息
```html
<div id="app-2">
  <span v-bind:title="message">
    鼠标悬停几秒钟查看此处动态绑定的提示信息！
  </span>
</div>

```
```js
var app2 = new Vue({
  el: '#app-2',
  data: {
    message: '页面加载于 ' + new Date().toLocaleString()
  }
})
```
v开头是一个指令，可以后接vue各种的特性，比如上例将title特性与message进行绑定。还可以使用if来进行判断。
```html
<div id="app-3">
  <p v-if="seen">现在你看到我了</p>
</div>

```
```js
var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})
```
如果修改app3的message为false，消息就消失了。

还可以用v-on添加一个事件监听
```html
<div id="app-5">
  <p>{{ message }}</p>
  <button v-on:click="reverseMessage">逆转消息</button>
</div>

```
```js
var app5 = new Vue({
  el: '#app-5',
  data: {
    message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})
```

v-model 还可以双向绑定修改input框中的内容，p中内容也会改变
```html
<div id="app-6">
  <p>{{ message }}</p>
  <input v-model="message">
</div>
```
```js
var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})
```

#### 组件化 component
vue可以通过小的组件来实现大的应用，组件非常类似于自定义元素。
```html
<div id="app-7">
  <ol>
<!--现在我们为每个 todo-item 提供 todo 对象todo 对象是变量，即其内容可以是动态的。我们也需要为每个组件提供一个“key”，稍后再作详细解释。-->
    <todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id"
    ></todo-item>
  </ol>
</div>
```
```js
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { id: 0, text: '蔬菜' },
      { id: 1, text: '奶酪' },
      { id: 2, text: '随便其它什么人吃的东西' }
    ]
  }
})
```
#### 实例
Vue的属性与用户定义的内容是分开来的
```js
var data = { a: 1 }
var vm = new Vue({
  el: '#example',
  data: data
})

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true

// $watch 是一个实例方法
vm.$watch('a', function (newValue, oldValue) {
  // 这个回调将在 `vm.a` 改变后调用
})
```
vue实例被创建的时候带有生命周期，可以用created来执行一个实例被创建后的函数
```js
new Vue({
  data: {
    a: 1
  },
  created: function () {
    // `this` 指向 vm 实例
    console.log('a is: ' + this.a)
  }
})
// => "a is: 1"
```
#### 样例
常用数据绑定形式就是双大括号，但是这种只是讲文本插入，如果要使用html就需要使用v-html
```html
<span>Message: {{ msg }}</span>
<span v-once> vonce使得此处内容插入后不能被修改：{{msg}}</span>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```
模板支持单个的js表达式
```html
{{ number + 1 }}

{{ ok ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('') }}

<div v-bind:id="'list-' + id"></div>
<!--这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。-->
<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}

<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```
在2.6版本中，可以用方括号括起来的一个js表达式作为一个指令的参数
```html
<a v-bind:[attributeName]="url"> ... </a>
<!--这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值
求得的值将会作为最终的参数来使用。
如果你的 Vue 实例有一个 data 属性 attributeName，其值为 "href"，那么这个绑定将等价于 v-bind:href。

同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：
-->
<a v-on:[eventName]="doSomething"> ... </a>
<!--同样地，当 eventName 的值为 "focus" 时，v-on:[eventName] 将等价于 v-on:focus。-->
```
v-bind和v-on都可以缩写
```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>
<!-- 缩写 -->
<a :href="url">...</a>
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>
<!-- 缩写 -->
<a @click="doSomething">...</a>
```
#### 计算属性 computed
可以在vue的实例里创建computed的属性。尽量不使用箭头函数，有时候会导致this指向错误。
```html
<div id="example">
  <p>Original message: "{{ message }}"</p>
  <p>Computed reversed message: "{{ reversedMessage }}"</p>
</div>

```
```js
var vm = new Vue({
  el: '#example',
  data: {
    message: 'Hello'
  },
  computed: {
    // 计算属性的 getter
    reversedMessage: function () {
      // `this` 指向 vm 实例
      return this.message.split('').reverse().join('')
    }
  }
})
```
这样就避免写出  {{ message.split('').reverse().join('') }}的不美观的内容。<br>
虽然在vue里使用方法可以起到同样的效果，但是区别在于，计算属性基于响应式依赖的缓存，即响应式依赖发生变化时才会重新求值。即message不变，调用reverMessage时都不会执行，而是直接返回在缓存中的内容。
```js
methods: {
  reversedMessage: function () {
    return this.message.split('').reverse().join('')
  }
}
```

#### 侦听属性 watch
有些数据会随着其他数据变化而变化，因此容易滥用watch，建议使用计算属性。
```js
<div id="demo">{{ fullName }}</div>

var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
    firstName: function (val) {
      this.fullName = val + ' ' + this.lastName
    },
    lastName: function (val) {
      this.fullName = this.firstName + ' ' + val
    }
  }
})

上面代码是命令式且重复的。将它与计算属性的版本进行比较：
var vm = new Vue({
  el: '#demo',
  data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
    fullName: function () {
      return this.firstName + ' ' + this.lastName
    }
  }
})
```

#### 计算属性的setter
```js
computed: {
       fullName: {
           // getter
           get: function () {
               return this.firstName + ' ' + this.lastName
           },
           // setter
           set: function (newValue) {
               var names = newValue.split(' ')
               this.firstName = names[0]
               this.lastName = names[names.length - 1]
           }
       }
   }
```
这样子就能对fullname进行修改

#### class与style绑定
```html
<div
  class="static"
  v-bind:class="{ active: isActive, 'text-danger': hasError }"
></div>
```
```js
data: {
  isActive: true,
  hasError: false
}
当然 可以写在data
<div v-bind:class="classObject"></div>
data: {
  classObject: {
    active: true,
    'text-danger': false
  }
}
也可以写成计算属性
data: {
  isActive: true,
  error: null
},
computed: {
  classObject: function () {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```
也可以应用成一个数组
```html
<div v-bind:class="[activeClass, errorClass]"></div>
```
```js
data: {
  activeClass: 'active',
  errorClass: 'text-danger'
}
```

用在组件上
```html
<my-component class="baz boo"></my-component>
<!-- 渲染结果-->
<p class="foo bar baz boo">Hi</p>
<!-- bind一样适用-->
<my-component v-bind:class="{ active: isActive }"></my-component>
```
**这些组件需要放在vue创建的内容下**
```js
Vue.component('my-component', {
  template: '<p class="foo bar">Hi</p>'
})
```
用在style上
```html
<div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```
```js
data: {
  activeColor: 'red',
  fontSize: 30
}
```
当然 直接绑定对象更好
```html
<div v-bind:style="styleObject"></div>
```
```js
data: {
  styleObject: {
    color: 'red',
    fontSize: '13px'
  }
}
```
#### 条件渲染 if
